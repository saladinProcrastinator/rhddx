<?php

/**
 * @file
 * Steps to perform after an install of the module.
 */
use \Drupal\file\Entity\File;

/**
 * Drupal hook (hook_install) to be run after the installation of this module.
 */
function redhat_developers_install()
{
    // Setting the front page to /
    $site = \Drupal::configFactory()->getEditable('system.site');
    $site->set('page.front', '/');
    $site->save(TRUE);

    require_once DRUPAL_ROOT . '/core/includes/file.inc';

    // Find all the images from the /tmp/images and also /tmp/stylesheets directory
    $mask = '/.*\.(png|jpg|jpeg|gif|svg|eot|ttf|woff)/';
    $site_images = array_merge(file_scan_directory('/tmp/images', $mask, array()),
        file_scan_directory('/tmp/stylesheets', $mask, array()));

    foreach ($site_images as $image) {
        // We need to build up the same idea as this from the ruby code:
        //
        // uri.path[0, uri.path.length - file_ext.length]
        //         .gsub(/[\/]/, "_")
        //         .gsub(/^[\.]{1,2}/, "")
        //
        // This way our file names will all match correctly after the cdn functions
        // from awestruct are used.

        // We're going ask for some basic info about the path, namely
        // * extension
        // * dirname
        $parts = pathinfo($image->uri);

        // We want to start at the `images` directory instead of the root of the
        // path of the file, so give us the path to the parent directory,
        // then tell us where `images` is at in that string
        $start = 0;
        if (strpos($parts['dirname'], 'images') !== FALSE) {
            $start = strpos($parts['dirname'], 'images');
        } else {
            $start = strpos($parts['dirname'], 'stylesheets') + strlen('stylesheets/'); // Need to start after 'stylesheets/'
        }

        // We're including the `.` as part of the extension, because we don't want
        // to include it just yet.
        $ext_length = strlen($parts['extension']) + 1;

        // Give us the path of the image, include parents, up to and including
        // 'images'. We'll then convert the `/` to `_` and finally add the
        // extension plus the `.` to finally arrive at the final filename.
        $cdn_id = substr($image->uri, $start, -1 * $ext_length);
        $cdn_id = preg_replace(['/[\/]/', '/^[\.]{1,2}/'], ['_', ''], $cdn_id)
            . '.' . $parts['extension'];


        \Drupal::logger('redhat-developers')->debug("Adding file @cdn_id as a permanent file", array('@cdn_id' => $cdn_id));
        $destination = 'public://' . $cdn_id;

        $uri = file_unmanaged_copy($image->uri, $destination, FILE_EXISTS_ERROR);

        // Since we now have the files in the correct location, we need create
        // an entry in the database for them, but only if that file is new, no
        // need in creating a new entry for an existing file.
        if ($uri !== FALSE) {
            $file = File::create([
                'uri' => $uri,
                'status' => FILE_STATUS_PERMANENT,
                'filename' => $image->filename,
                'filemime' => \Drupal::service('file.mime_type.guesser')->guess($uri),
                'filesize' => filesize($uri)
            ]);
            $file->save();
        }
    }
}

/**
 * Add langcode field to file_revision table.
 *
 * This is required before updating to Drupal 8.2.
 * Otherwise, 'drush entup' reports -
 *   file entity type :
 *     The Language code field needs to be updated.
 *
 * The entity update fails with an SQL syntax error. The cause is
 * the Multiversion module which created the file_revision table.
 *
 * This function updates the storage without having to do a risky
 * migration of all files.
 */
function redhat_developers_update_8200() {
    try {
        $langcode_storage_schema = [
          'file_managed' => [
            'fields' => [
              'langcode' => [
                'type' => 'varchar_ascii',
                'length' => 12,
                'not null' => TRUE,
              ],
            ],
          ],
          'file_revision' => [
            'fields' => [
              'langcode' => [
                'type' => 'varchar_ascii',
                'length' => 12,
                'not null' => TRUE,
              ],
            ],
          ],
        ];
        \Drupal::keyValue('entity.storage_schema.sql')
          ->set('file.field_schema_data.langcode', $langcode_storage_schema);

        $database = \Drupal::database();
        $table_name = 'file_revision';
        $column_name = 'langcode';
        if ($database->schema()->tableExists($table_name) && !$database->schema()
            ->fieldExists($table_name, $column_name)
        ) {
            $database->schema()->addField($table_name, $column_name, [
              'type' => 'varchar',
              'length' => '12',
              'not null' => TRUE,
              'description' => 'Language code',
              'default' => 'en-gb',
            ]);

            $update_manager = \Drupal::entityDefinitionUpdateManager();
            $update_manager->updateEntityType($update_manager->getEntityType('file'));
            $langcode_storage = $update_manager->getFieldStorageDefinition('langcode', 'file');
            $langcode_storage->setRevisionable(TRUE);
            $update_manager->updateFieldStorageDefinition($langcode_storage);
        }
    } catch (\Exception $e) {
        \Drupal::logger('MY_MODULE')->error($e->getMessage());
    }
}

